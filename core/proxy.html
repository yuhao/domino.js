<script>
'use strict';

din.exportTo("proxy", function(){
  var objHandler = {
    get: function(target, name){
      console.plog("[Proxy] Read", name, typeof target[name]);

      if (target[name] === null) {
        return null;
      } else {
        if (typeof target[name] === "object") {
          if (name === "_src") {
            // If we are accessing obj_proxy._src, we want obj,
            // not obj_proxy._src._proxy which is obj_proxy itself!
            return target;
          }
          else if (name === "_proxy") {
            // obj_proxy._proxy shouldn't return obj._proxy._proxy which is
            // obj_proxy._proxy, and then we have an infinite loop! We print
            // a warning and return obj._proxy to prevent the infinite loop.
            // This can only happen when we are checking isOrHasProxy of
            // obj_proxy. Otherwise, it shouldn't neven happen because
            // technically a proxy object shouldn't have a _proxy property!
            return target[name];
          } else {
            return createObjProxy(target[name]);
          }
        } else if (typeof target[name] === "function") {
          if (name === "hasOwnProperty") {
            // Do not create a proxy for |hasOwnProperty|, otherwise there is
            // an infinite loop when calling |hasOwnProperty| from the
            // |hasOwnProperty| proxy (see |apply| in funcHandler).
            return target[name];
          } else {
            return createFuncProxy(target[name]);
          }
        } else {
          return target[name];
        }
      }
    },

    set: function(target, name, val){
      try {
        target[name] = val;
        console.plog("[Proxy] Write", name, typeof target[name]);
      }
      catch (e) {
        console.plog(e)
        throw(e)
      }
      return true;
    }
  };

  var funcHandler = {
    apply: function(target, thisArg, argumentsList) {
      // Change the proxy argument to its _src
      var numArgs = argumentsList.length;
      for (var i = 0;i < numArgs;i++) {
        if (typeof argumentsList[i] === "object" && din.util.isOrHasProxy(argumentsList[i]))
          argumentsList[i] = argumentsList[i]._src;
      }

      var returnVal;
      if (thisArg === null || thisArg === undefined || !thisArg.hasOwnProperty("_src")) {
		// Sometimes a proxy function is called with |this| as a non-proxy.
		// Examples include |this| being |null|, |undefined|, |window.document|,
		// or just a plain object that does not have a proxy.  Note that it's
		// possible for window.document to have ._src if it's set through
		// someEl.ownerDocument
        returnVal = target.apply(thisArg, argumentsList);
      } else {
        returnVal = target.apply(thisArg._src, argumentsList);
      }

      if (typeof returnVal === "object") {
        return createObjProxy(returnVal);
      } else if (typeof returnVal === "function") {
        return createFuncProxy(returnVal);
      } else {
        return returnVal;
      }
    }
  };

  // TODO: maybe we want to consolidate obj and func proxy creation?
  // https://github.com/yuhao/ticket.js/issues/5
  // createObjProxy makes sure that if an obj already has a proxy, that
  // existing proxy will be returned and NO new proxy will be created.
  // TODO: Also it is not possible to create a proxy of a proxy object (good?).
  // https://github.com/yuhao/ticket.js/issues/9
  function createObjProxy(node) {
    if (node === null || typeof node !== "object")
      return node;

    if (node.hasOwnProperty("_proxy"))
      return node._proxy;

    console.plog("[Proxy] create Proxy for", node.constructor.name);
    var node_proxy = new Proxy(node, objHandler);
    // Install cross-references between src and proxy
    // Note that both the src and proxy will have both cross-references!
    node._proxy = node_proxy;
    node_proxy._src = node;

    return node_proxy;
  }

  function createFuncProxy(func) {
    if (func === null || typeof func !== "function")
      return func;

    if (func.hasOwnProperty("_proxy"))
      return func._proxy;

    console.plog("[Proxy] create Func Proxy for", func.name);
    var func_proxy = new Proxy(func, funcHandler);
    func._proxy = func_proxy;
    func_proxy._src = func;

    // Calling toString() on a proxy function will throw a TypeError.
    func_proxy.toString = function() {
      return Function.prototype.toString.apply(this._src);
    };

    return func_proxy;
  }

  return {
    createObjProxy: createObjProxy,
    createFuncProxy: createFuncProxy
  }
});
</script>
