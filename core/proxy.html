<script>
  'use strict';

  function isOrHasProxy(obj) {
    return obj.hasOwnProperty("_proxy") || obj.hasOwnProperty("_src")
  }

  var objHandler = {
    get: function(target, name){
      console.log("[Proxy] Read", name, typeof target[name]);

      if (target[name] === null) {
        return null;
      } else {
        if (typeof target[name] === "object") {
          if (name === "_src") {
            // If we are accessing obj_proxy._src, we want obj,
            // not obj_proxy._src._proxy which is obj_proxy itself!
            return target;
          }
          else if (name === "_proxy") {
            // obj_proxy._proxy shouldn't return obj._proxy._proxy which is
            // obj_proxy._proxy, and then we have an infinite loop! We print
            // a warning and return obj._proxy to prevent the infinite loop.
            // This shouldn't neven happen anyways because technically a
            // proxy object shouldn't have a _proxy property!
            console.error("Should neve access obj_proxy._proxy!");
            return target[name];
          } else {
            return createObjProxy(target[name]);
          }
        } else if (typeof target[name] === "function") {
          if (name === "hasOwnProperty") {
            return target[name];
          } else {
            return createFuncProxy(target[name]);
          }
        } else {
          return target[name];
        }
      }
    },
  
    set: function(target, name, val){
      try {
        target[name] = val;
        console.log("[Proxy] Write", name, typeof target[name]);
      }
      catch (e) {
        // TODO: Placeholder for future exception handlings such as richer
        // logging. For now, just throw the exception.
        //console.log(e)
        throw(e)
      }
      return true;
    }
  };

  var funcHandler = {
    apply: function(target, thisArg, argumentsList) {
      // Change the proxy argument to its _src
      var numArgs = argumentsList.length;
      for (var i = 0;i < numArgs;i++) {
        if (typeof argumentsList[i] === "object" && isOrHasProxy(argumentsList[i]))
          argumentsList[i] = argumentsList[i]._src;
      }

      var returnVal;
      if (thisArg === null || thisArg === undefined || !thisArg.hasOwnProperty("_src")) {
        // Sometimes a proxy function is called with |this| as a non-proxy.
        // Examples include |this| being |null|, |undefined|, |window.document|,
        // or just a plain object that does not have a proxy.
        returnVal = target.apply(thisArg, argumentsList);
      } else {
        returnVal = target.apply(thisArg._src, argumentsList);
      }

      if (typeof returnVal === "object") {
        return createObjProxy(returnVal);
      } else if (typeof returnVal === "function") {
        return createFuncProxy(returnVal);
      } else {
        return returnVal;
      }
      return returnVal;
    }
  };

  // TODO: maybe we want to consolidate obj and func proxy creation?
  // createObjProxy makes sure that if an obj already has a proxy, that
  // existing proxy will be returned and NO new proxy will be created.
  function createObjProxy(node) {
    if (node === null || typeof node !== "object")
      return node;

    if (node.hasOwnProperty("_proxy"))
      return node._proxy;

    console.log("[Proxy] create Proxy for", node.constructor.name);
    var node_proxy = new Proxy(node, objHandler);
    // Install cross-references between src and proxy
    // Note that both the src and proxy will have both cross-references!
    node._proxy = node_proxy;
    node_proxy._src = node;
  
    return node_proxy;
  }

  function createFuncProxy(func) {
    if (func === null || typeof func !== "function")
      return func;

    if (func.hasOwnProperty("_proxy"))
      return func._proxy;

    console.log("[Proxy] create Func Proxy for", func.name);
    var func_proxy = new Proxy(func, funcHandler);
    func._proxy = func_proxy;
    func_proxy._src = func;
  
    return func_proxy;
  }
</script>
